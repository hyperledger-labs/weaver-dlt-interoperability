"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryImpl = void 0;
const gatewayutils_1 = require("../gatewayutils");
const Logger = __importStar(require("../../logger"));
const logger = Logger.getLogger('Query');
/**
 * @private
 */
class QueryImpl {
    /**
     * Builds a Query instance to send and then work with the results returned
     * by the fabric-common/Query.
     * @param {module:fabric-common.Query} query - The query instance of the proposal
     * @returns {Object} options - options to be used when sending the request to
     * fabric-common service endpoint {Endorser} peer.
     */
    constructor(query, options = {}) {
        this.query = query;
        this.requestTimeout = 3000; // default 3 seconds
        if (options.timeout && Number.isInteger(options.timeout)) {
            this.requestTimeout = options.timeout * 1000; // need ms;
        }
    }
    /**
     * Sends a signed proposal to the specified peers. The peer endorsment
     * responses are
     * @param {Endorser[]} peers - The peers to query
     * @returns {Object.<String, (QueryResponse | Error)>} Object with peer name keys and associated values that are either
     * QueryResponse objects or Error objects.
     */
    async evaluate(peers) {
        const method = 'evaluate';
        logger.debug('%s - start', method);
        const results = {};
        try {
            const responses = await this.query.send({ targets: peers, requestTimeout: this.requestTimeout });
            if (responses) {
                if (responses.errors) {
                    for (const resultError of responses.errors) {
                        results[resultError.connection.name] = resultError;
                        logger.debug('%s - problem with query to peer %s error:%s', method, resultError.connection.name, resultError);
                    }
                }
                if (responses.responses) {
                    for (const peerResponse of responses.responses) {
                        if (peerResponse.response) {
                            const response = newQueryResponse(peerResponse);
                            results[peerResponse.connection.name] = response;
                            logger.debug('%s - have results - peer: %s with status:%s', method, peerResponse.connection.name, response.status);
                        }
                    }
                }
                // check to be sure we got results for each peer requested
                for (const peer of peers) {
                    if (!results[peer.name]) {
                        logger.error('%s - no results for peer: %s', method, peer.name);
                        results[peer.name] = new Error('Missing response from peer');
                    }
                }
            }
            else {
                throw Error('No responses returned for query');
            }
        }
        catch (error) {
            // if we get an error, return this error for each peer
            for (const peer of peers) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                results[peer.name] = error;
                logger.error('%s - problem with query to peer %s error:%s', method, peer.name, error);
            }
        }
        logger.debug('%s - end', method);
        return results;
    }
}
exports.QueryImpl = QueryImpl;
function newQueryResponse(endorseResponse) {
    const isEndorsed = endorseResponse.endorsement ? true : false;
    const payload = isEndorsed ? (0, gatewayutils_1.asBuffer)((0, gatewayutils_1.getTransactionResponse)(endorseResponse).payload) : endorseResponse.response.payload;
    return {
        isEndorsed,
        message: endorseResponse.response.message,
        payload,
        status: endorseResponse.response.status,
    };
}
//# sourceMappingURL=query.js.map