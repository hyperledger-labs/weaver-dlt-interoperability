"use strict";
/*
 * Copyright 2019 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionEventHandler = void 0;
const timeouterror_1 = require("../../errors/timeouterror");
const transactionerror_1 = require("../../errors/transactionerror");
const Logger = __importStar(require("../../logger"));
const logger = Logger.getLogger('TransactionEventHandler');
/**
 * Handles events for a given transaction. Used to wait for a submitted transaction to be successfully commited to
 * the ledger.
 * Delegates to an event strategy to decide whether events or errors received should be interpreted as success or
 * failure of a transaction.
 * @private
 */
class TransactionEventHandler {
    /**
     * Constructor.
     * @private
     * @param {Transaction} transaction - Transaction object.
     * @param {Object} strategy - Event strategy implementation.
     * @param {TransactionOptions} [options] Additional options.
     */
    constructor(transactionId, network, strategy) {
        this.listener = this.eventCallback.bind(this);
        this.strategySuccessCallback = this.strategySuccess.bind(this);
        this.strategyFailCallback = this.strategyFail.bind(this);
        const method = 'constructor';
        this.transactionId = transactionId;
        this.network = network;
        this.strategy = strategy;
        const defaultOptions = {
            commitTimeout: 30
        };
        this.options = Object.assign(defaultOptions, network.getGateway().getOptions().eventHandlerOptions);
        logger.debug('%s: transactionId = %s, options = %j', method, this.transactionId, this.options);
        this.peers = strategy.getPeers();
        this.unrespondedPeers = new Set(this.peers);
        this.notificationPromise = new Promise((resolve) => {
            this.resolveNotificationPromise = resolve;
        });
    }
    /**
     * Called to initiate listening for transaction events.
     */
    async startListening() {
        const method = 'startListening';
        if (this.peers && this.peers.length > 0) {
            logger.debug('%s - have eventService list - start monitoring', method);
            this.setListenTimeout();
            await this.network.addCommitListener(this.listener, this.peers, this.transactionId);
        }
        else {
            logger.error('%s - No event services', method);
            // shutdown the monitoring
            this.resolveNotificationPromise();
        }
    }
    /**
     * Wait until enough events have been received from the event services to satisfy the event handling strategy.
     * @throws {Error} if the transaction commit is not successful within the timeout period.
     */
    async waitForEvents() {
        logger.debug('waitForEvents start');
        const err = await this.notificationPromise;
        if (err) {
            throw err;
        }
        logger.debug('waitForEvents end');
    }
    /**
     * Cancel listening for events.
     */
    cancelListening() {
        logger.debug('cancelListening called');
        if (this.timeoutHandler) {
            clearTimeout(this.timeoutHandler);
        }
        this.network.removeCommitListener(this.listener);
    }
    eventCallback(error, event) {
        if (event && !event.isValid) {
            const message = `Commit of transaction ${this.transactionId} failed on peer ${event.peer.name} with status ${event.status}`;
            this.strategyFail(new transactionerror_1.TransactionError({
                message,
                transactionId: event.transactionId,
                transactionCode: event.status
            }));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const peer = (error === null || error === void 0 ? void 0 : error.peer) || event.peer;
        if (!this.unrespondedPeers.delete(peer)) {
            // Already seen a response from this peer
            return;
        }
        if (error) {
            this.strategy.errorReceived(this.strategySuccessCallback, this.strategyFailCallback);
        }
        else {
            this.strategy.eventReceived(this.strategySuccessCallback, this.strategyFailCallback);
        }
    }
    setListenTimeout() {
        const method = 'setListenTimeout';
        if (typeof this.options.commitTimeout !== 'number' || this.options.commitTimeout <= 0) {
            logger.debug('%s - no commit timeout', method);
            return;
        }
        logger.debug('%s setTimeout(%s) in seconds for transaction %s', method, this.options.commitTimeout, this.transactionId);
        this.timeoutHandler = setTimeout(() => {
            this.timeoutFail();
            logger.error('%s - event handler timed out', method);
        }, this.options.commitTimeout * 1000);
        logger.debug('%s - end', method);
    }
    timeoutFail() {
        const unrespondedPeerNames = Array.from(this.unrespondedPeers)
            .map((peer) => peer.name)
            .join(', ');
        const errorInfo = {
            message: 'Event strategy not satisfied within the timeout period. No response received from peers: ' + unrespondedPeerNames,
            transactionId: this.transactionId
        };
        const error = new timeouterror_1.TimeoutError(errorInfo);
        this.strategyFail(error);
    }
    /**
     * Callback for the strategy to indicate successful commit of the transaction.
     * @private
     */
    strategySuccess() {
        logger.debug('strategySuccess: commit success for transaction %j', this.transactionId);
        this.cancelListening();
        this.resolveNotificationPromise();
    }
    /**
     * Callback for the strategy to indicate failure of the transaction commit.
     * @private
     * @param {Error} error Reason for failure.
     */
    strategyFail(error) {
        logger.warn('strategyFail: commit failure for transaction %j: %s', this.transactionId, error);
        this.cancelListening();
        this.resolveNotificationPromise(error);
    }
}
exports.TransactionEventHandler = TransactionEventHandler;
//# sourceMappingURL=transactioneventhandler.js.map