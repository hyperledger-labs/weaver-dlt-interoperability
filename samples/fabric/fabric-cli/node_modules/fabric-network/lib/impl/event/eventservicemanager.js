"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventServiceManager = void 0;
const GatewayUtils = __importStar(require("../gatewayutils"));
const Logger = __importStar(require("../../logger"));
const logger = Logger.getLogger('EventSourceManager');
class EventServiceManager {
    constructor(network) {
        this.eventServices = new Map();
        this.network = network;
        this.channel = network.getChannel();
        this.mspId = network.getGateway().getIdentity().mspId;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.identityContext = this.network.getGateway().identityContext;
        logger.debug('constructor - network:%s', this.network.getChannel().name);
    }
    /**
     * Get a shared event service that can only be used for realtime listening to filtered events. These event services
     * provide high performance event listening for commit events.
     * @param peer Peer from which to receive events.
     * @returns An event service.
     */
    getCommitEventService(peer) {
        let eventService = this.eventServices.get(peer);
        if (!eventService) {
            eventService = this.newEventService([peer]);
            this.eventServices.set(peer, eventService);
        }
        return eventService;
    }
    /**
     * Use this method to be sure the event service has been connected and has been started. If the event service is not
     * started, it will start the service based on the options provided. If the event service is already started, it
     * will check that the event service is compatible with the options provided.
     * @param eventService EventService to be started if it not already started.
     * @param options The options to start the event service.
     */
    async startEventService(eventService, options = {}) {
        logger.debug('startEventService - start %s', this.network.getChannel().name);
        if (eventService.isStarted() || eventService.isInUse()) {
            return this.assertValidOptionsForStartedService(options, eventService);
        }
        eventService.build(this.identityContext, options);
        eventService.sign(this.identityContext);
        // targets must be previously assigned
        await eventService.send();
    }
    newDefaultEventService() {
        const peers = this.getEventPeers();
        GatewayUtils.shuffle(peers);
        return this.newEventService(peers);
    }
    close() {
        this.eventServices.forEach((eventService) => eventService.close());
    }
    /**
     * This method will build fabric-common Eventers and the fabric-common
     * EventService. The Eventers will not be connected to the endpoint at
     * this time. Since the endorsers have been previously connected, the
     * endpoint should be accessable. The EventService will check the connection
     * and perform the connect during the send() when it starts the service.
     * @param peers The Endorser service endpoints used to build a
     *  a list of {@link Eventer} service endpoints that will be used as the
     *  targets of the new EventService.
     */
    newEventService(peers) {
        const serviceName = this.createName(peers);
        const eventService = this.channel.newEventService(serviceName);
        const eventers = peers.map((peer) => this.newEventer(peer));
        eventService.setTargets(eventers);
        return eventService;
    }
    newEventer(peer) {
        const eventer = this.channel.client.newEventer(peer.name);
        eventer.setEndpoint(peer.endpoint);
        return eventer;
    }
    createName(peers) {
        return peers.map((peer) => peer.name).join(',');
    }
    assertValidOptionsForStartedService(options, eventService) {
        if (options.blockType && options.blockType !== eventService.blockType) {
            throw new Error('EventService is not receiving the correct blockType');
        }
        if (options.startBlock) {
            throw new Error('EventService is started and not usable for replay');
        }
    }
    getEventPeers() {
        const orgPeers = this.getOrganizationPeers();
        return orgPeers.length > 0 ? orgPeers : this.getNetworkPeers();
    }
    getOrganizationPeers() {
        return this.channel.getEndorsers(this.mspId);
    }
    getNetworkPeers() {
        return this.channel.getEndorsers();
    }
}
exports.EventServiceManager = EventServiceManager;
//# sourceMappingURL=eventservicemanager.js.map