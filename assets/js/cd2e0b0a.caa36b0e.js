"use strict";(self.webpackChunkweaver_dlt_interoperability=self.webpackChunkweaver_dlt_interoperability||[]).push([[5261],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),u=r,f=c["".concat(l,".").concat(u)]||c[u]||h[u]||o;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9805:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={},i=void 0,s={unversionedId:"internal/development/cordapp-interop/cordapp-interop",id:"internal/development/cordapp-interop/cordapp-interop",isDocsHomePage:!1,title:"cordapp-interop",description:"\x3c!--",source:"@site/docs/internal/development/cordapp-interop/cordapp-interop.md",sourceDirName:"internal/development/cordapp-interop",slug:"/internal/development/cordapp-interop/cordapp-interop",permalink:"/weaver-dlt-interoperability/docs/internal/development/cordapp-interop/cordapp-interop",editUrl:"https://github.com/hyperledger-labs/weaver-dlt-interoperability/edit/master/docs/internal/development/cordapp-interop/cordapp-interop.md",tags:[],version:"current",frontMatter:{}},l=[{value:"General Corda notes",id:"general-corda-notes",children:[],level:2},{value:"1. Authentication of external networks",id:"1-authentication-of-external-networks",children:[{value:"Foreign Network Information Management",id:"foreign-network-information-management",children:[{value:"FNIM CorDapp Assets",id:"fnim-cordapp-assets",children:[],level:4},{value:"FNIM API Assets",id:"fnim-api-assets",children:[],level:4},{value:"FNIM Flows",id:"fnim-flows",children:[],level:4},{value:"FNIM Query Flows",id:"fnim-query-flows",children:[],level:4},{value:"FNIM application REST API and Corda flow connections",id:"fnim-application-rest-api-and-corda-flow-connections",children:[],level:4}],level:3},{value:"Access Control",id:"access-control",children:[{value:"Access Control CorDapp Assets",id:"access-control-cordapp-assets",children:[],level:4},{value:"Access Control API Assets",id:"access-control-api-assets",children:[],level:4},{value:"Access Control Flows",id:"access-control-flows",children:[],level:4},{value:"Access Control Query Flows",id:"access-control-query-flows",children:[],level:4},{value:"Access Control Application REST API and Corda Flow Connections",id:"access-control-application-rest-api-and-corda-flow-connections",children:[],level:4}],level:3}],level:2},{value:"2. Handle external networks querying a Corda application for state",id:"2-handle-external-networks-querying-a-corda-application-for-state",children:[{value:"Handle Requests From Foreign Network - CorDapp Assets",id:"handle-requests-from-foreign-network---cordapp-assets",children:[],level:4},{value:"Handle Requests From Foreign Network - API Assets",id:"handle-requests-from-foreign-network---api-assets",children:[],level:4},{value:"Handle Requests From Foreign Network - Flows",id:"handle-requests-from-foreign-network---flows",children:[],level:4},{value:"Handle Requests From Foreign Network - Application REST API and Corda Flow Connections",id:"handle-requests-from-foreign-network---application-rest-api-and-corda-flow-connections",children:[],level:4}],level:2},{value:"3. Requests to get state from external networks",id:"3-requests-to-get-state-from-external-networks",children:[{value:"Request State from External Network - CorDapp Assets",id:"request-state-from-external-network---cordapp-assets",children:[],level:4},{value:"WriteStateFromExternalNetworkFlows",id:"writestatefromexternalnetworkflows",children:[],level:4},{value:"Application REST API and Corda flow connections",id:"application-rest-api-and-corda-flow-connections",children:[],level:4}],level:2}],d={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"id: cordapp-interop\ntitle: Interoperation CorDapp"),(0,r.kt)("hr",null),(0,r.kt)("h1",{id:"interoperation-cordapp"},"Interoperation CorDapp"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"  Contributors:    Chander Govindarajan, Allison Irvin, Isabell Kiral"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"This document contains the specification for the interoperation application including the system, the CorDapp flow design and the application server details.\nThis CorDapp serves as the bridge between an established CorDapp and the relay.\nThere are three main functions of the Interoperation CorDapp:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"It defines states, contracts and flows for authenticating participants of an external network and providing access control to Corda application states. "),(0,r.kt)("li",{parentName:"ol"},"It defines flows for enabling an external network to query a Corda application."),(0,r.kt)("li",{parentName:"ol"},"It defines flows for enabling a Corda application to query an external network.")),(0,r.kt)("p",null,"The Corda interoperability application consists of the CorDapp itself, containing flows, contracts and state definitions, as well as a webserver with a REST API that connects to the Corda nodes via RPC to trigger flows.\nThere is no user interface for the interoperability functionality.\nThe REST API is designed to be consumed by a Corda application that wishes to incorporate state synchronisation with an external network. "),(0,r.kt)("p",null,"To view the assets, flows and API specification in full without any of the descriptions see these pages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/weaver-dlt-interoperability/docs/internal/development/cordapp-interop/cordapp-interop-assets"},"CorDapp Assets"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/weaver-dlt-interoperability/docs/internal/development/cordapp-interop/cordapp-interop-api-assets"},"API Assets"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/weaver-dlt-interoperability/docs/internal/development/cordapp-interop/cordapp-interop-flows"},"Flows"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/weaver-dlt-interoperability/docs/internal/development/cordapp-interop/cordapp-interop-rest-api"},"REST API")),(0,r.kt)("hr",{parentName:"li"}))),(0,r.kt)("h2",{id:"general-corda-notes"},"General Corda notes"),(0,r.kt)("p",null,"Corda provides many state interfaces to aid in standardisation across CorDapps.\nStates must extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractState")," interface, which contains a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractParty"),", called ",(0,r.kt)("inlineCode",{parentName:"p"},"participants"),".\nThis defines which Corda identities must sign off on transactions that consume state of that type.\nFor states where instances evolve by superseding itself, Corda provides the ",(0,r.kt)("inlineCode",{parentName:"p"},"LinearState")," interface.\nThis includes a property ",(0,r.kt)("inlineCode",{parentName:"p"},"linearId"),", which is a unique identifier that all versions of the state will preserve throughout the lifecycle of the state. "),(0,r.kt)("h2",{id:"1-authentication-of-external-networks"},"1. Authentication of external networks"),(0,r.kt)("h3",{id:"foreign-network-information-management"},"Foreign Network Information Management"),(0,r.kt)("p",null,"In order to control access to state in a Corda application or to verify state coming from an external network, the Corda network needs to have some way of authenticating parties in the external network.\nThe Foreign Network Information Management (FNIM) state contains a network map of the foreign network, including an identifier associated with the foreign network as well as a description of each of the foreign network nodes (",(0,r.kt)("inlineCode",{parentName:"p"},"FNNode"),"s).\nThis FNIM state is used to verify the identity of external network parties interacting with the Corda network.\nEvery interaction requires a signature of the external network party.\nThe signature is verified against the provided certificate and the authenticity of the certificate is verified against the FNIM state.\nIn our current design, the definition of these ",(0,r.kt)("inlineCode",{parentName:"p"},"FNNode"),"s is very Fabric-centric, as the Fabric-Fabric interoperability design used the network map the way it was stored on the Ordering Service channel.\nIn order to not have to make significant changes to the way the Fabric network published its network map, this format was used to consume the FNIM in the Interoperation CorDapp, complete with fields such as ",(0,r.kt)("inlineCode",{parentName:"p"},"crypto_config")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fabric_node_ous"),".\nThe Fabric nodes' info was also stored as a key-value with the key being the name of the Fabric organisation (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"SellerMSP"),").\nIn a more generalised interoperation protocol, we should think about common features that all DLT networks are required to provide in order for external networks to be able to properly identify and authenticate participants. "),(0,r.kt)("p",null,"An FNIM state is created for an external network on the level of a group of Corda participants.\nThe Corda participants that are listed in the FNIM state are responsible for creating the FNIM state and ensuring it is kept up to date with the external network configuration.\nIn the current model, this is done manually, with the endpoint to fetch the network map from the external network through the relay hardcoded into the interoperation REST API endpoint.\nThis endpoint is also used to update the FNIM state when the foreign network topology changes.\nThe application middleware checks if there is an FNIM state for that networkId already, and if so, deletes it before creating a new state with the updated details.\nIn our demo, the participants of the FNIM state are also hardcoded.\nThe flow that creates an FNIM state does not require any manual sign-off by counterparties.\nThe flow triggers a subflow in all participant nodes listed in the state, that checks the transaction against the contract and signs the transaction if the verification passes. "),(0,r.kt)("p",null,"In a more generalised protocol, it would be preferable to have a standardised format for the publication of network maps.\nFor example, having a decentralised identity platform for the storage of DLT network that were discoverable by other networks would be ideal.\nOtherwise, having all networks provide their network map through a consistent API, would also be helpful."),(0,r.kt)("p",null,"The Corda parties that control the creation and management of FNIM states in the Corda network also needs to be revisited.\nFor example, ensuring currency of an FNIM state for a particular external network could be up to a group of participants that share some state together that they wish to have synchronised with the external network.\nAlternatively, a dedicated group of Corda parties could be responsible for maintaining currency of the configurations of all the external networks that any group of participants may wish to interoperate with in a Corda network.\nThe mechanism for updating FNIM state when external network configuration changes should also be revisited, rather than deleting the existing state and creating a new one. "),(0,r.kt)("p",null,"Similarly to the requirement for a Corda network to have access to the network map of an external network, the external network must also have a snapshot of the Corda network they wish to interoperate with in order to validate requests and responses.\nThe exposure of the network map is currently done through the individual Corda applications as the information that each network wishes to share externally will vary on a case-by-case basis.\nThis model can be revised if needed for the next iteration of the protocol."),(0,r.kt)("h4",{id:"fnim-cordapp-assets"},"FNIM CorDapp Assets"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class ForeignNetworkInformationManagementState(\n        linearId: UniqueIdentifier = UniqueIdentifier(),\n        participants: List<Party>,\n        networkId: String,\n        topology: List<FNNode>\n) : LinearState\n\nclass FNNode(\n        admins: List<String>,\n        crypto_config: CryptoConfig,\n        fabric_node_ous: String?,\n        intermediate_certs: List<String>,\n        name: String,\n        organizational_unit_identifiers: List<String>,\n        revocation_list: List<String>,\n        root_certs: List<String>,\n        signing_identity: String?,\n        tls_intermediate_certs: List<String>,\n        tls_root_certs: List<String>\n)\n\nclass CryptoConfig(\n        identity_identifier_hash_function: String,\n        signature_hash_family: String\n)\n")),(0,r.kt)("h4",{id:"fnim-api-assets"},"FNIM API Assets"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class FNIMStateRequest(\n        networkId: String,\n        topology: List<FNNode>,\n        participants: List<String>\n)\n\nclass FNIMStateResponse(\n        linearId: UniqueIdentifier,\n        networkId: String,\n        topology: List<FNNode>,\n        participants: List<String>\n)\n\nclass ForeignNetworkMapInformationIntermediateResponse(\n    CarrierMSP:  FNNode,\n    SellerMSP: FNNode\n)\n")),(0,r.kt)("h4",{id:"fnim-flows"},"FNIM Flows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class FNIMInitiator(\n    networkId: String,\n    topology: List<FNNode>,\n    participants: List<Party>) {\n    // creates FNIM record for an external network\n}\n\nclass FNIMExitInitiator(\n    id: String ) {\n    // marks FNIM state as consumed\n}\n")),(0,r.kt)("h4",{id:"fnim-query-flows"},"FNIM Query Flows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class QueryForeignNetworkInformationManagementStates : List<ForeignNetworkInformationManagementState> {\n    // returns list of FNIM states\n}\n\nclass QueryForeignNetworkInformationManagementStatesById(\n    linearId: UniqueIdentifier) ForeignNetworkInformationManagementState {\n    // returns FNIM state\n}\n\nclass QueryForeignNetworkInformationManagementStateByNetworkId(\n    networkId: String) ForeignNetworkInformationManagementState {\n    // returns FNIM state for specified network\n}\n")),(0,r.kt)("h4",{id:"fnim-application-rest-api-and-corda-flow-connections"},"FNIM application REST API and Corda flow connections"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET storeFNIM\nreq: {}\nres: ForeignNetworkMapInformationIntermediateResponse, or failure\ncalls: \n    1. <foreign-network-id-and-certs-configuration-url> to get ForeignNetworkMapInformationIntermediateResponse\n    2. QueryForeignNetworkInformationManagementStateByNetworkId to check if FNIM exists for this network already\n    3. FNIMExitInitiator (if FNIM exists already)\n    4. FNIMInitiator\n\nPOST foreignNetworkInfos\nreq: FNIMStateRequest\nres: FNIMStateResponse, or failure\ncalls: FNIMInitiator\n\nDELETE foreignNetworkInfos/{id}\nreq: {}\nres: id, or failure\ncalls: FNIMExitInitiator\n\nGET foreignNetworkInfos\nreq: {}\nres: List<ForeignNetworkInformationManagementState>, or failure\ncalls: QueryForeignNetworkInformationManagementStates\n\nGET foreignNetworkInfos/{id}\nreq: {}\nres: ForeignNetworkInformationManagementState, or failure\ncalls: QueryForeignNetworkInformationManagementStatesById\n")),(0,r.kt)("h3",{id:"access-control"},"Access Control"),(0,r.kt)("p",null,"The Interoperation CorDapp allows groups of Corda parties to grant access to their application states through ",(0,r.kt)("inlineCode",{parentName:"p"},"AccessControlStates"),".\nThese Access Control states are issued on a per-application state and per-external network basis (for example, for a particular letter of credit and for a particular external network).\nThe application state for which the Access Control state pertains is denoted by the ",(0,r.kt)("inlineCode",{parentName:"p"},"stateLinearId")," and the external network is specified by the ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkId")," that should match the ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkId")," for the FNIM state.\nThe Access Control state also lists the certificates of the parties of the external network who are allowed to make requests for state.\nThese are included in the ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkCertificates")," field. "),(0,r.kt)("p",null,"This is just one approach that could be used to grant access to foreign network participants.\nIt may be desirable to be able to set access control rules on a Corda application level (e.g. allow one Access Control state to govern access to ",(0,r.kt)("em",{parentName:"p"},"all")," Corda states for a given application).\nTherefore, this may need to be revisited for the next version of the interoperation protocol."),(0,r.kt)("p",null,"As the Access Control state defines whether an external party can access state from the Corda ledger, explicit approval needs to be given by each participant of the Corda state.\nThese approvals are captured in an Access Control Request State.\nOnce all participants have manually approved the request through initiating the ",(0,r.kt)("inlineCode",{parentName:"p"},"AccessControlIssueRequestApprover"),", an Access Control state will be created. "),(0,r.kt)("p",null,"The workflow to grant access to application states needs to be built into the application for a particular CorDapp.\nFor example, as a part of a trade logistics application, one part of the user interface could include allowing particular external network participants to request a current view of a letter of credit state.\nAll participants of that letter of credit would have to approve the access control request before it becomes active.\nThis workflow was not built into the Corda-Fabric interoperability demo, with the creation and approval of an Access Control request being triggered through the interoperation middleware when an external network request for Corda state is received."),(0,r.kt)("h4",{id:"access-control-cordapp-assets"},"Access Control CorDapp Assets"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class AccessControlIssueRequestState(\n        linearId: UniqueIdentifier = UniqueIdentifier(),\n        externalNetworkId: String,\n        externalNetworkCertificates: List<String>,\n        requestApprovals: List<DigitalSignature.WithKey>,\n        stateLinearId: UniqueIdentifier,\n        participants: List<Party>\n) : LinearState\n\nclass AccessControlState(\n        linearId: UniqueIdentifier = UniqueIdentifier(),\n        externalNetworkId: String,\n        externalNetworkCertificates: List<String>,\n        stateLinearId: UniqueIdentifier,\n        participants: List<Party>\n) : LinearState\n")),(0,r.kt)("h4",{id:"access-control-api-assets"},"Access Control API Assets"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class AccessControlIssueRequestStateRequest(\n    externalNetworkId: String,\n    externalNetworkCertificates: List<String>,\n    stateLinearId: String,\n    participants: List<String>\n)\n\nclass AccessControlIssueRequestStateResponse(\n        linearId: UniqueIdentifier,\n        externalNetworkId: String,\n        externalNetworkCertificates: List<String>,\n        requestApprovals: List<String>,\n        stateLinearId: String,\n        participants: List<String>\n)\n\nclass AccessControlStateResponse(\n        linearId: UniqueIdentifier,\n        externalNetworkId: String,\n        externalNetworkCertificates: List<String>,\n        stateLinearId: String,\n        participants: List<String>\n)\n")),(0,r.kt)("h4",{id:"access-control-flows"},"Access Control Flows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class AccessControlIssueRequestInitiator(\n        externalNetworkCertificates: List<String>,\n        externalNetworkId: String,\n        stateLinearId: UniqueIdentifier,\n        participants: List<Party> {\n    // Creates an access control request on the ledger for a particular document\n}\n\nclass AccessControlIssueRequestApprover(\n    id: UniqueIdentifier){\n    // Allows for a party to approve an access control issuance request\n    // Once all parties listed as a participant of the state the access control request pertains to\n    // have approved the request, an AccessControlState is created\n}\n")),(0,r.kt)("h4",{id:"access-control-query-flows"},"Access Control Query Flows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class QueryAccessControlIssueRequestStates() List<AccessControlIssueRequestState> {\n    // returns access control requests\n}\n\nclass QueryAccessControlIssueRequestStateByLinearId(linearId: UniqueIdentifier) AccessControlIssueRequestState {\n    // returns access control request by Id\n}\n\nclass QueryAccessControlStates() List<AccessControlState> {\n    // returns list of access control states\n}\n\nclass QueryAccessControlStateByLinearId(linearId: UniqueIdentifier) AccessControlState {\n    // returns access control state by Id\n}\n\nclass QueryAccessControlStatesByStateIdAndNetworkId(\n        stateLinearId: UniqueIdentifier,\n        externalNetworkId: String\n    ) AccessControlState {\n    // returns access control state by the linearId of the application state and the external network Id\n}\n")),(0,r.kt)("h4",{id:"access-control-application-rest-api-and-corda-flow-connections"},"Access Control Application REST API and Corda Flow Connections"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"POST accessControlRequests/new\nreq: AccessControlIssueRequestStateRequest\nres: AccessControlIssueRequestStateResponse, or failure\ncalls: AccessControlIssueRequestInitiator\n\nPOST /accessControlRequests/approve/{id}\nreq: id\nres: AccessControlIssueRequestStateResponse, or failure\ncalls: AccessControlIssueRequestApprover\n\nGET accessControlRequests\nreq: {}\nres: AccessControlIssueRequestStateResponse, or failure\ncalls: QueryAccessControlIssueRequestStateByLinearId\n\nGET accessControlStates\nreq: {}\nres: List<AccessControlState>, or failure\ncalls: QueryAccessControlStates\n\nGET accessControlStates/{id}\nreq: {}\nres: AccessControlStateResponse, or failure\ncalls: QueryAccessControlIssueRequestStateByLinearId\n")),(0,r.kt)("h2",{id:"2-handle-external-networks-querying-a-corda-application-for-state"},"2. Handle external networks querying a Corda application for state"),(0,r.kt)("p",null,"An external network can make a request for Corda state by reaching the interoperability CorDapp through the relay. "),(0,r.kt)("p",null,"For an external network request to be successful it must fulfill the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The identity of the requester needs to be authenticated through a signature on the request and a provided certificate. The signature is either made on the ",(0,r.kt)("inlineCode",{parentName:"li"},"linearId")," or the ",(0,r.kt)("inlineCode",{parentName:"li"},"txId")," that is provided in the request."),(0,r.kt)("li",{parentName:"ol"},"The certificate needs to be validated against the FNIM stored for the external network (i.e. the certificate needs to be issued by an issuing CA listed in the FNIM and the hierarchy of certificates in the FNIM needs to be validated up to the rootCA)."),(0,r.kt)("li",{parentName:"ol"},"The desired state needs to be located in the vault of the Corda node processing the request."),(0,r.kt)("li",{parentName:"ol"},"A corresponding Access Control state needs to be found for the desired state and the certificate of the requester needs to be listed in the Access Control state.")),(0,r.kt)("p",null,"The Corda node processing the request then needs to assemble a response object that includes the desired state and a signature on the state that provides evidence that this was the current view of the state according to that node.\nThe Corda node then needs to forward the request on to all participants of the state, who run through the same process for validation of the request and assembly of the response object.\nThe responses from each of the Corda nodes are collected by the initial Corda node and returned to the relay who pass the response back to the requesting network.\nCollectively, the responses from all Corda nodes (provided they shared the same view of the state) should be enough to convince the requester of the current state in the Corda ledger.\nThis assumes that the requesting network trusts that the Corda network participants are not colluding to misrepresent the state.\nWhether we want to provide stronger assurances of the currency and finality of state by requiring the Notary also sign off on the state can be assessed in the next iteration."),(0,r.kt)("p",null,"There must be some way of identifying the desired Corda state without necessitating that the interoperation Cordapp be aware of the data classes of the Corda application.\nIn Fabric, this was done by the requesting network passing the chaincode query function name and the query in the request.\nIn Corda, this approach needs to be revisited because there is no concept of a chaincode query function.\nThe initial approach taken in the demo was to identify the Corda state by linearId as this guarantees that the state can be uniquely identified in the vault.\nHowever, there is no guarantee that states will have a unique identifier as not all application states will extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"LinearState")," interface.\nAs well, the ",(0,r.kt)("inlineCode",{parentName:"p"},"linearId")," is a property generated in Corda on creation of the state and may be meaningless in the business process.\nTherefore, it cannot be assumed that an external network will have visibility of the ",(0,r.kt)("inlineCode",{parentName:"p"},"linearId"),".\nOur workaround for the demo was to create a custom endpoint ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkRequestByTxId")," where the desired state was identified by a property unique to a letter of credit - the ",(0,r.kt)("inlineCode",{parentName:"p"},"txId"),".\nA set of linearIds that corresponded to that txId were then found using a custom flow called ",(0,r.kt)("inlineCode",{parentName:"p"},"GetLinearIdsFromTxId"),".\nThe request was then validated according to the criteria above (valid signature, valid certificate according to FNIM, valid Access Control state) and a response object generated for each state located by linearId.\nOther approaches that could be more appropriate for Corda may include creating query flows in the CorDapp application that work in a similar way to chaincode query functions.\nThis would involve investigating if cross-CorDapp triggering of flows is possible, and if so, how they can be executed.\nAnother approach could be requiring a ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomQueryCriteria")," in the request that comes from the external network.\nAgain, we would have to investigate if ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomQueryCriteria")," can be used in a CorDapp that has no knowledge of the application states for which that query pertains.\nRegardless of the approach to address state within Corda, for the next iteration of the protocol we need to think about how to generalise this across enterprise DLTs. "),(0,r.kt)("p",null,"Another workaround for the demo also of note here is the automatic generation of an Access Control state for the states specified in the request.\nAs we had not implemented any workflow or user interface in the Corda application for granting access to external network participants, creation of an Access Control state was triggered when the interoperation CorDapp received a request from an external network.\nNote that the functionality for a Corda application to incorporate the creation of Access Control states into their workflows is present in the interoperation APIs.\nThis workaround was put in place purely because the demo did not include a demonstration of this workflow.\nSome further thought will need to be put into the workflow in the application CorDapp, especially with how external network parties are represented (for example, will the application CorDapp require access to the participant certificates listed in the FNIM?)."),(0,r.kt)("p",null,"Things to think about in the next iteration of the protocol:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Trust model of the relay - does the request need to be encrypted?"),(0,r.kt)("li",{parentName:"ul"},"How do we address the Corda nodes in the request so the relay can know which node to forward the request on to"),(0,r.kt)("li",{parentName:"ul"},"Do we need to include guidelines about the encryption and signature schemes that can be used? Will accepted encryption and signature schemes vary on a network-by-network basis? If so, do we need some way of publishing what encryption and signature schemes a network accepts?"),(0,r.kt)("li",{parentName:"ul"},"How to generalise the addressing of state? In Corda this could be a ",(0,r.kt)("inlineCode",{parentName:"li"},"CustomQueryCriteria"),", in Fabric this is currently done through chaincode function and query"),(0,r.kt)("li",{parentName:"ul"},"How to handle multiple states being found"),(0,r.kt)("li",{parentName:"ul"},"Next iteration needs to handle replay attacks - provide a nonce in the request"),(0,r.kt)("li",{parentName:"ul"},"Currently the ",(0,r.kt)("inlineCode",{parentName:"li"},"organizationName")," of the requester is required in the request. We need a more general way of linking the requester identity with the issuing CA in the FNIM. ")),(0,r.kt)("h4",{id:"handle-requests-from-foreign-network---cordapp-assets"},"Handle Requests From Foreign Network - CorDapp Assets"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"StateQueryResponse")," is the object assembled by each Corda node for each requested state.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"requestedState")," field is a JSON string of the ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryResponse")," that is encoded in Base64 as a bytearray.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"certificate")," is the certificate of the Corda node providing the state and is used by the requesting network to validate the signature and the identity of the Corda node against their locally stored copy of the Corda network FNIM.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"signature")," is the signature of the Corda node signed on the ",(0,r.kt)("inlineCode",{parentName:"p"},"requestedState")," bytearray. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," field in ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryResponse")," is a JSON string of the Corda application state.\nFor the demo, some of the JSON attributes were manipulated by converting to lowercase from camelcase, and renaming some fields.\nThis was done as the Fabric application was expecting the letter of credit state to be returned in a particular form.\nIdeally, the Interoperation CorDapp would not manipulate the state in any way before it is returned.\nIt also cannot be expected that the Corda application needs to modify its data structures in any way to conform with an external network's data structure.\nIt should be up to the consuming network to parse the state it receives into a meaningful format for its own application. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class StateQueryResponse(\n    requestedState: ByteArray, \n    certificate: ByteArray,\n    signature: ByteArray \n)\n\nclass QueryResponse(\n        state: String,\n        linearId: String\n)\n")),(0,r.kt)("h4",{id:"handle-requests-from-foreign-network---api-assets"},"Handle Requests From Foreign Network - API Assets"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExternalNetworkRequest")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ExternalNetworkRequestWithTxId")," are the two request bodies that the external network can provide.\nThese are based on whether the external network is identifying the Corda application state by ",(0,r.kt)("inlineCode",{parentName:"p"},"linearId")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"txId"),".\nAs mentioned previously, for the demo the latter request type was used as we assumed that the external network would not have any visibility of the ",(0,r.kt)("inlineCode",{parentName:"p"},"linearId")," property of a Corda state.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkId")," needs to match with the ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkId")," used to store the FNIM for the requesting network.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"organizationName")," is a Fabric-specific artifact that stems from the way identities are grouped under organizations.\nThis field is needed in order to validate the identity of the requester in the FNIM by finding the correct issuing CA of the credentials.\nThis will need to be revised in the next iteration of the protocol as the FNIM will need to be generalised to be applicable to all enterprise DLTs. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class ExternalNetworkRequest(\n    externalNetworkId: String,\n    organizationName: String,\n    requesterCertificate: String,\n    requesterSignature: String,\n    stateLinearId: String\n)\n\nclass ExternalNetworkRequestWithTxId(\n    externalNetworkId: String,\n    organizationName: String,\n    requesterCertificate: String,\n    requesterSignature: String,\n    txId: String\n)\n")),(0,r.kt)("h4",{id:"handle-requests-from-foreign-network---flows"},"Handle Requests From Foreign Network - Flows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class StateQueryInitiator(\n    externalNetworkId: String,\n    organizationName: String,\n    stateLinearId: UniqueIdentifier,\n    requesterCertString: String,\n    requesterSignature: String,\n    txId: String?\n) List<StateQueryResponse> {\n    // returns requested state and associated proof\n}\n\nclass GetLinearIdsFromTxId(\n    txId: String\n) List<UniqueIdentifier> {\n    // returns list ids for states that match the query criterion\n}\n")),(0,r.kt)("h4",{id:"handle-requests-from-foreign-network---application-rest-api-and-corda-flow-connections"},"Handle Requests From Foreign Network - Application REST API and Corda Flow Connections"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkRequest POST")," endpoint is used to find the Corda application state based on ",(0,r.kt)("inlineCode",{parentName:"p"},"linearId"),".\nIt will return a ",(0,r.kt)("inlineCode",{parentName:"p"},"StateQueryResponse")," for each Corda node listed as a participant in the state, or in the case that a state is not found or access is denied for the requester, will fail.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkRequestByTxId POST")," endpoint finds Corda application state based on ",(0,r.kt)("inlineCode",{parentName:"p"},"txId")," and could potentially match with multiple states.\nTherefore, for each accessible state found, each Corda node listed as a participant in the state will provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"StateQueryResponse"),".\nIf no states are found or the requester does not have permission to access the state, an empty list will be returned.\nNote that the access control calls that are made are purely a workaround from the fact that the setup of state access control was not built into the demo."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"POST externalNetworkRequest\nreq: ExternalNetworkRequest\nres: List<StateQueryResponse>, or failure\ncalls: \n    1. <interoperation-webserver1-url>/accessControlRequests/new\n    2. <interoperation-webserver2-url>/accessControlRequests/approve\n    3. StateQueryInitiator\n\nPOST externalNetworkRequestByTxId\nreq: ExternalNetworkRequestWithTxId\nres: List<List<StateQueryResponse>?>\ncalls: \n    1. <interoperation-webserver1-url>/accessControlRequests/new\n    2. <interoperation-webserver2-url>/accessControlRequests/approve\n    3. GetLinearIdsFromTxId\n    4. StateQueryInitiator (for each linearId)\n")),(0,r.kt)("h2",{id:"3-requests-to-get-state-from-external-networks"},"3. Requests to get state from external networks"),(0,r.kt)("p",null,"In the opposite case from the previous section, the Interoperation CorDapp also allows a Corda application to request a state from an external network.\nThis consists of the following steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A Corda application uses the Interoperation CorDapp API to trigger the request to the external network (takes a ",(0,r.kt)("inlineCode",{parentName:"li"},"ExternalStateRequest"),")"),(0,r.kt)("li",{parentName:"ol"},"The Interoperation CorDapp creates a request object to send to the foreign network's relay (",(0,r.kt)("inlineCode",{parentName:"li"},"RelayRequestObject"),")"),(0,r.kt)("li",{parentName:"ol"},"The returned state and proofs are validated"),(0,r.kt)("li",{parentName:"ol"},"The external network's state is stored in the vault along with the associated proofs"),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"linearId")," of the state is returned to the Corda application"),(0,r.kt)("li",{parentName:"ol"},"The Corda application retrieves the state from the vault")),(0,r.kt)("h4",{id:"request-state-from-external-network---cordapp-assets"},"Request State from External Network - CorDapp Assets"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ExternalStateRequest")," is the request object the webserver receives as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"POST requestExternalState")," endpoint.\nIt is used by the webserver to know how to address the relay and it is also passed on to the ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateExternalRequestStateObject")," flow to construct the request object that will be forwarded to the relay.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"url")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"path")," are required to the webserver knows how to address the relay to forward the request on to.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkId")," identifies the external network the relay needs to forward the request to and needs to match the id used in the FNIM.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"arguments")," contains the arguments that will be passed to the specified chaincode function, ",(0,r.kt)("inlineCode",{parentName:"p"},"function"),".\nThese parameters, ",(0,r.kt)("inlineCode",{parentName:"p"},"arguments")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," are very Fabric-centric and we should generalise the method of addressing state across DLTs for future iterations of the interoperation protocol.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"participants")," is the list of Corda participants that will need own the Fabric state when it is stored in Corda.\nTo make this code a little cleaner, we should probably have the request object received by the webserver defined in the API assets, which should include ",(0,r.kt)("inlineCode",{parentName:"p"},"url"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"path"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"participants")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"requestParameters"),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"requestParameters")," would be forwarded on to the ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateExternalRequestStateObject")," flow, and would only include those fields relevant to the flow (",(0,r.kt)("inlineCode",{parentName:"p"},"externalNetworkId"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"arguments"),").\nHowever, seeing as the way we address state in a more general protocol is going to change, we probably don't need to worry about cleaning this up in the demo code. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class ExternalStateRequest(\n        url: String,\n        path: String,\n        externalNetworkId: String,\n        arguments: String,\n        function: String,\n        participants: List<String>\n)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RelayRequestObject")," is what the interoperation CorDapp sends to the relay to forward on to the Fabric network.\n",(0,r.kt)("inlineCode",{parentName:"p"},"operationType")," defines the type of operation the Corda network wants to perform on the chaincode - either ",(0,r.kt)("inlineCode",{parentName:"p"},"INVOKE")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"QUERY"),".\nFor now, the ",(0,r.kt)("inlineCode",{parentName:"p"},"QUERY")," operation is the only one that is supported on the Fabric end and is hardcoded in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateExternalRequestStateObject")," flow where an instance of  ",(0,r.kt)("inlineCode",{parentName:"p"},"RelayRequestObject")," is created.\nTo be consistent, ",(0,r.kt)("inlineCode",{parentName:"p"},"operationType")," should probably have been included in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExternalStateRequest")," that was passed into the flow.\nAgain, seeing as the way we address state is going to change, we won't worry about changing the demo code.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"policy")," refers to the endorsement policy of the Fabric channel for the particular state that the Corda application is requesting.\nA more detailed discussion of how the ",(0,r.kt)("inlineCode",{parentName:"p"},"policy")," is defined and how it ",(0,r.kt)("em",{parentName:"p"},"should")," be defined is in the ",(0,r.kt)("a",{parentName:"p",href:"#writestatefromexternalnetworkflows"},"flows section"),".\nThe fields ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"arguments")," are copied across from what is provided in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExternalStateRequest")," that comes from the client application.\nOn the Fabric end, the Fabric nodes will want to authenticate the Corda node making the request - enabled through ",(0,r.kt)("inlineCode",{parentName:"p"},"clientOrganizationId"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"clientCertificate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"clientSignature"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class RelayRequestObject(\n        operationType: String,\n        policy: String,\n        function: String,\n        arguments: List<String>,\n        clientOrganizationId: String,\n        clientCertificate: String,\n        clientSignature: String\n)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ExternalStateObjectState")," is the way the state and proof that is returned from the external network is saved as a state in the Corda vault."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class ExternalStateObjectState(\n        linearId: UniqueIdentifier = UniqueIdentifier(),\n        participants: List<Party>,\n        externalState: String,\n        externalNetworkId: String,\n        responseObject: List<FormattedResponse>\n) : LinearState\n\nclass FormattedResponse(\n        organizationName: String,\n        decryptedPayload: String,\n        certString: String,\n        signatureBytes: ByteArray,\n        message: ByteArray,\n        publicKey: PublicKey\n)\n\nclass RelayResponseObject(\n        requestId: String,\n        status: String,\n        response: List<NodeResponse>?\n)\n\nclass NodeResponse(\n        proposal: String,\n        proposalResponse: String\n)\n\nclass RelayRequestId(\n        requestId: String\n)\n\nclass ParsedQueryObject(\n        linearId: UniqueIdentifier,\n        txId: String?\n)\n\nclass NetworkMapObject(\n        networkId: String,\n        nodes: List<Node>\n)\n\nclass Node(\n        name: String,\n        address: String,\n        hierarchicalCerts: List<ByteArray>,\n        hierarchicalCANames: List<String>\n)\n")),(0,r.kt)("h4",{id:"writestatefromexternalnetworkflows"},"WriteStateFromExternalNetworkFlows"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateExternalRequestStateObject")," flow takes the request from the Corda application (through the webserver) and creates the request object that the relay needs to pass on to the external network.\nIt first looks up the FNIM for the external network based off the provided external netowrk id.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"policy")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"RelayRequestObject")," is created by concatenating the name of each of the ",(0,r.kt)("inlineCode",{parentName:"p"},"FNNode"),"s that are present in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ForeignNetworkInformationManagementState")," for that network, separated by the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," symbol (e.g. for the demo ",(0,r.kt)("inlineCode",{parentName:"p"},"SellerMSP & CarrierMSP"),").\nThis approach is not ideal as it is very Fabric-centric and is currently hardcoded to be all of the nodes listed in the FNIM for the network, which may or may not be the correct endorsement policy needed for the state.\nHow endorsement policy should be represented in the interoperation CorDapp has been raised as an ",(0,r.kt)("a",{parentName:"p",href:"https://github.ibm.com/dlt-interoperability/cordapp-interop/issues/35"},"issue in the ",(0,r.kt)("inlineCode",{parentName:"a"},"cordapp-interop")," repo"),'.\nThe endorsement policy is a concept that is present in all permissioned DLTs (although not always called "endorsement policy").\nIt refers to the set of parties who have ownership of a state, or who control the update of a state.\nWe should generalise this concept in the next iteration of the protocol and store the endorsement policies for an external network as states that can be looked up by the interop CorDapp.\nThe ',(0,r.kt)("inlineCode",{parentName:"p"},"clientCertificate")," is a string of the Corda node X.509 certificate in PEM format.\nThe signature is a Base 64 string, signed on a concatenation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"function"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"arguments")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"clientOrganizationId")," represented as Base 64 byte arrays."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class CreateExternalRequestStateObject(\n        request: ExternalStateRequest\n) RelayRequestObject {\n    // returns request object to query relay about a foreign network state\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"WriteExternalStateInitiator")," flow is used to verify the state proof that is returned from the external network and commit the state to the vault. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class WriteExternalStateInitiator(\n    nodeResponses: List<NodeResponse>,\n    externalNetworkId: String,\n    participants: List<Party>\n) UniqueIdentifier {\n    // writes external state to ledger and returns unique identifier to be used to query from MarcoPolo\n}\n")),(0,r.kt)("h4",{id:"application-rest-api-and-corda-flow-connections"},"Application REST API and Corda flow connections"),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"POST requestExternalState\nreq: ExternalStateRequest\nres: UniqueIdentifier, or failure\ncalls: \n    1. CreateExternalRequestStateObject\n    2. HTTP POST request to relay with the provided url and path\n    3. HTTP GET request to relay to get the response from the external network\n    4. WriteExternalStateInitiator\n")))}p.isMDXComponent=!0}}]);